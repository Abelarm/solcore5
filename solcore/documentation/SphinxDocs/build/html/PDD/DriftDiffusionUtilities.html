<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Drift Diffusion Utilities &mdash; Solcore 4.1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '4.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Solcore 4.1.0 documentation" href="../index.html" />
    <link rel="up" title="Poisson - Drift-Diffusion solver (PDD)" href="DDsolver.html" />
    <link rel="next" title="QW unit creator" href="QWunit.html" />
    <link rel="prev" title="Device Structure" href="DeviceStructure.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="QWunit.html" title="QW unit creator"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="DeviceStructure.html" title="Device Structure"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Solcore 4.1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="DDsolver.html" accesskey="U">Poisson - Drift-Diffusion solver (PDD)</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="drift-diffusion-utilities">
<h1>Drift Diffusion Utilities<a class="headerlink" href="#drift-diffusion-utilities" title="Permalink to this headline">¶</a></h1>
<p>This module is the interface between Python and Fortran. It takes a structure created with the tools in <a class="reference internal" href="DeviceStructure.html"><span class="doc">Device Structure</span></a> and dumps all that information into the Fortran variables. Then, it runs the selected &#8216;virtual experiment&#8217;. This process is completeley transparent for the user who only needs to run the desired experiment with the structure as the input.</p>
<div class="section" id="virtual-experiments">
<h2>Virtual experiments<a class="headerlink" href="#virtual-experiments" title="Permalink to this headline">¶</a></h2>
<p>At the end of this page there is a detailed description of the format of all the functions withi this module, but here we focuse in the more practical aspect, including also exambles of usage.</p>
<dl class="function">
<dt id="ProcessStructure">
<code class="descname">ProcessStructure</code><span class="sig-paren">(</span><em>device</em><span class="optional">[</span>, <em>wavelengths=None</em>, <em>use_Adachi = False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ProcessStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps the structure of the device into the fortran code and calculates an apropiate mesh, based on the values of the mesh_control variable. An initial estimation of the quasi-Fermi energies, electrostatic potential and carrier concentration is also performed. This will be used as inicial condition for the numerical solver. Absorption coeficients are not calculated unless <em>wavelengths</em> is given as input.</p>
<p>If <em>use_Adachi = True</em>, the absorption is calculated (if necesary) using the method described by S. Adachi in <a class="footnote-reference" href="#ref1" id="id1">[1]</a>. Otherwise, interpolated experimental data is used.</p>
<p><strong>Output</strong> (see <a class="reference internal" href="#output-dictionary"><span class="std std-ref">Output dictionary</span></a>): <strong>Properties</strong></p>
</dd></dl>

<dl class="function">
<dt id="Equilibrium">
<code class="descname">Equilibrium</code><span class="sig-paren">(</span><em>device</em><span class="optional">[</span>, <em>output_info=2</em>, <em>wavelengths=None</em>, <em>use_Adachi = False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Equilibrium" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the Poisson-DD equations under equilibrium: in the dark with no external current and zero applied voltage. Internally, it calls <em>ProcessStructure</em>. Absorption coeficients are not calculated unless <em>wavelengths</em> is given as input.</p>
<p><em>output_info</em> controls how much information is printed in the terminal by the solver. It can be 1 (less) or 2 (more).</p>
<p><strong>Output</strong> (see <a class="reference internal" href="#output-dictionary"><span class="std std-ref">Output dictionary</span></a>): <strong>Properties</strong> and <strong>Bandstructure</strong></p>
</dd></dl>

<dl class="function">
<dt id="ShortCircuit">
<code class="descname">ShortCircuit</code><span class="sig-paren">(</span><em>device</em><span class="optional">[</span>, <em>sol=&quot;AM1.5d&quot;</em>, <em>rs=0</em>, <em>output_info=1</em>, <em>use_Reflection=True</em>, <em>use_Adachi = False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ShortCircuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the Poisson-DD equations under short circuit conditions: current flowing trhought the structure due to the light absorbed and zero applied voltage. It calls internally to <em>Equilibrium</em> before appliying the illumination. <em>sol</em> can be a string with the name of the standard spectrum to use - &#8216;AM1.5d&#8217;, &#8216;AM1.5g&#8217; or &#8216;AM0&#8217; <a class="footnote-reference" href="#ref4" id="id2">[2]</a>- or an object of class <em>solcore3.PDD.Illumination</em> (see <a class="reference internal" href="Illumination.html"><span class="doc">Illumination</span></a>). If one of the standard spectra is used, the default wavelength range will be from 300 nm to 1100 nm every 4 nm.</p>
<p><em>use_Reflection</em> controls whether the calculation should account for the front surface reflection or not.</p>
<p><em>output_info</em> controls how much information is printed in the terminal by the solver. It can be 1 (less) or 2 (more).</p>
<p><strong>Output</strong> (see <a class="reference internal" href="#output-dictionary"><span class="std std-ref">Output dictionary</span></a>): <strong>Properties</strong>, <strong>Bandstructure</strong> and <strong>Optics</strong></p>
<p>Example 1: We use as starting point the structure created in the example 2 of <a class="reference internal" href="DeviceStructure.html"><span class="doc">Device Structure</span></a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">solcore3.PDD</span> <span class="k">as</span> <span class="nn">PDD</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># First we load the device structure stored in MyDevice.json</span>
<span class="n">MyDevice</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="s1">&#39;MyDevice&#39;</span><span class="p">)</span>

<span class="c1"># Then we run two virtual experiments, just calculate the structure under equilibrum and under short circuit conditions.</span>
<span class="c1"># We use the default settings of the solver.</span>
<span class="n">EQ</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">Equilibrium</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">)</span>
<span class="n">SC</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">ShortCircuit</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">)</span>

<span class="c1"># Finally, we plot the carrier densities in both cases using the information stored in the output dictionaries</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">EQ</span><span class="p">[</span><span class="s1">&#39;Bandstructure&#39;</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">e9</span><span class="p">,</span> <span class="n">EQ</span><span class="p">[</span><span class="s1">&#39;Bandstructure&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39; n equilibrium&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">EQ</span><span class="p">[</span><span class="s1">&#39;Bandstructure&#39;</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">e9</span><span class="p">,</span> <span class="n">EQ</span><span class="p">[</span><span class="s1">&#39;Bandstructure&#39;</span><span class="p">][</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39; p equilibrium&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">SC</span><span class="p">[</span><span class="s1">&#39;Bandstructure&#39;</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">e9</span><span class="p">,</span> <span class="n">SC</span><span class="p">[</span><span class="s1">&#39;Bandstructure&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39; n short circuit&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">SC</span><span class="p">[</span><span class="s1">&#39;Bandstructure&#39;</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">e9</span><span class="p">,</span> <span class="n">SC</span><span class="p">[</span><span class="s1">&#39;Bandstructure&#39;</span><span class="p">][</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39; p short circuit&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Carrier densities (m-3)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Position (nm)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="docutils">
<dt></dt>
<dd><p class="first">The result of the above calculation is this:</p>
<img alt="../_images/EQandSC.png" class="last align-center" src="../_images/EQandSC.png" />
</dd>
</dl>
<dl class="function">
<dt id="IV">
<code class="descname">IV</code><span class="sig-paren">(</span><em>device</em>, <em>vfin</em>, <em>vstep</em><span class="optional">[</span>, <em>output_info=1</em>, <em>IV_info=True</em>, <em>rs=0</em>, <em>escape = 1</em>, <em>sol=None</em>, <em>use_Adachi = False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#IV" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the IV curve of the device from <em>V = 0V</em> to <em>V = Vfin</em>. It calls internally to <em>Equilibrium</em> or <em>ShortCircuit</em>, depending if the dark or the lght IV is to be calculated. Voltage steps are equal to <em>vstep</em> in the dark but are dynamically reduced in light IV around the maximum power point and Voc to do a proper mapping of that fast-changing region. If <em>sol</em> is given as input, then the solver calculates the light IV. In this case, <em>escape = 1</em> ends the calculation when the Voc is reached. <em>IV_info = True</em> prints the Jsc, Voc, Jmpp, Vmpp and FF at the end of the calculation.</p>
<p>Note that the sign of the voltages and the currents for direct biasing the solar cell depends on having a PN or an NP device.</p>
<p><em>output_info</em> controls how much information is printed in the terminal by the solver. It can be 1 (less) or 2 (more).</p>
<p><strong>Output</strong> (see <a class="reference internal" href="#output-dictionary"><span class="std std-ref">Output dictionary</span></a>): <strong>Properties</strong>, <strong>Bandstructure</strong> at the last voltage point and <strong>IV</strong>. If light IV, then also <strong>Optics</strong>.</p>
<p>Example 2: Using the same structure that before, we calculate the dark current, plotting the different components that contribute to it.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">solcore3.PDD</span> <span class="k">as</span> <span class="nn">PDD</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># First we load the device structure stored in MyDevice.json</span>
<span class="n">MyDevice</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="s1">&#39;MyDevice&#39;</span><span class="p">)</span>

<span class="c1"># We use the default settings of the solver to calculate the dark IV.</span>
<span class="n">IV</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">IV</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span> <span class="n">vfin</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">vstep</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="c1"># Finally, we plot the different components of the dark current using the information stored in the output dictionaries</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;J&#39;</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Jtot&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;Jrad&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Jrad&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;Jsrh&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Jsrh&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;Jsur&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Jsur&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Current density (A/m2)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="docutils">
<dt></dt>
<dd><p class="first">The result of the above calculation is this:</p>
<img alt="../_images/IV.png" class="last align-center" src="../_images/IV.png" />
</dd>
</dl>
<dl class="docutils">
<dt></dt>
<dd><p class="first">Example 3: Now we calculate the light IV curve under the AM1.5d spectrum assuming Rs = 0 Ohm m2 and Rs = 0.001 Ohm m2</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">solcore3.PDD</span> <span class="k">as</span> <span class="nn">PDD</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># First we load the device structure stored in MyDevice.json</span>
<span class="n">MyDevice</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="s1">&#39;MyDevice&#39;</span><span class="p">)</span>

<span class="c1"># We use the default settings of the solver to calculate the light IV.</span>
<span class="n">IV</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">IV</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span> <span class="n">vfin</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">vstep</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">sol</span><span class="o">=</span><span class="s2">&quot;AM1.5d&quot;</span><span class="p">)</span>
<span class="n">IVrs</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">IV</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span> <span class="n">vfin</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">vstep</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">sol</span><span class="o">=</span><span class="s2">&quot;AM1.5d&quot;</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>

<span class="c1"># Finally, we plot the two curves</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="o">-</span><span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;J&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Rs = 0 Ohm m2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">IVrs</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">],</span> <span class="o">-</span><span class="n">IVrs</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;J&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Rs= 0.001 Ohm m2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.1</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">IV</span><span class="p">[</span><span class="s1">&#39;IV&#39;</span><span class="p">][</span><span class="s1">&#39;J&#39;</span><span class="p">])</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Current density (A/m2)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="docutils">
<dt></dt>
<dd><p class="first">The result of the above calculation is this:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="28%" />
<col width="28%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"></th>
<th class="head">Rs = 0</th>
<th class="head">Rs = 10</th>
<th class="head">Ohm cm2</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Jsc</td>
<td>20.873</td>
<td>20.866</td>
<td>mA/cm2</td>
</tr>
<tr class="row-odd"><td>Voc</td>
<td>0.895</td>
<td>0.895</td>
<td>V</td>
</tr>
<tr class="row-even"><td>FF</td>
<td>0.843</td>
<td>0.648</td>
<td>-</td>
</tr>
</tbody>
</table>
<img alt="../_images/LightIV.png" class="last align-center" src="../_images/LightIV.png" />
</dd>
</dl>
<dl class="function">
<dt id="QE">
<code class="descname">QE</code><span class="sig-paren">(</span><em>device</em><span class="optional">[</span>, <em>sol=&quot;AM1.5d&quot;</em>, <em>rs=0</em>, <em>output_info=1</em>, <em>use_Reflection=True</em>, <em>use_Adachi = False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#QE" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the quantum efficiency at short circuit with bias light given by <em>sol</em>. By defualt, reflection if the front surface is included in the calculation.</p>
<p><em>output_info</em> controls how much information is printed in the terminal by the solver. It can be 1 (less) or 2 (more).</p>
<p><strong>Output</strong> (see <a class="reference internal" href="#output-dictionary"><span class="std std-ref">Output dictionary</span></a>): <strong>Properties</strong>, <strong>Bandstructure</strong> at the last wavelength point, <strong>Optics</strong> and <strong>QE</strong>.</p>
<p>Example 4: Finally, we calculate the quantum efficiency, plotting the internal and the external ones.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">solcore3.PDD</span> <span class="k">as</span> <span class="nn">PDD</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># First we load the device structure stored in MyDevice.json</span>
<span class="n">MyDevice</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="s1">&#39;MyDevice&#39;</span><span class="p">)</span>

<span class="c1"># We use the default settings of the solver to calculate the QE.</span>
<span class="n">QE</span> <span class="o">=</span> <span class="n">PDD</span><span class="o">.</span><span class="n">QE</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">)</span>

<span class="c1"># Finally, we plot the internal and external quantum efficiencies using the information stored in the output dictionaries</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">QE</span><span class="p">[</span><span class="s1">&#39;QE&#39;</span><span class="p">][</span><span class="s1">&#39;wavelengths&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="n">QE</span><span class="p">[</span><span class="s1">&#39;QE&#39;</span><span class="p">][</span><span class="s1">&#39;IQE&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;IQE&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">QE</span><span class="p">[</span><span class="s1">&#39;QE&#39;</span><span class="p">][</span><span class="s1">&#39;wavelengths&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="n">QE</span><span class="p">[</span><span class="s1">&#39;QE&#39;</span><span class="p">][</span><span class="s1">&#39;EQE&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;EQE&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;QE (%)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavelength (nm)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="docutils">
<dt></dt>
<dd><p class="first">The result of the above calculation is this:</p>
<img alt="../_images/QE.png" class="last align-center" src="../_images/QE.png" />
</dd>
</dl>
</div>
<div class="section" id="get-data-from-fortran">
<h2>Get data from Fortran<a class="headerlink" href="#get-data-from-fortran" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="DumpInputProperties">
<code class="descname">DumpInputProperties</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DumpInputProperties" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="DumpBandStructure">
<code class="descname">DumpBandStructure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DumpBandStructure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="DumpIV">
<code class="descname">DumpIV</code><span class="sig-paren">(</span><span class="optional">[</span><em>IV_info=False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#DumpIV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="DumpQE">
<code class="descname">DumpQE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#DumpQE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p></p>
<blockquote>
<div>Functions used to retrieve the current data from the Fortran variables. They produce as output a dictionary with the corresponding set of variables.</div></blockquote>
</div>
<div class="section" id="setting-different-aspects-of-the-solver">
<h2>Setting different aspects of the solver<a class="headerlink" href="#setting-different-aspects-of-the-solver" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="SetMeshParameters">
<code class="descname">SetMeshParameters</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#SetMeshParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters that control the meshing of the structure. Changing this values might improve convergence in some difficult cases. The absolute maximum number of meshpoints at any time is 6000. The keywords and default values are:</p>
<ul>
<li><dl class="first docutils">
<dt><strong>meshpoints = -400</strong></dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">Defines the type of meshing that must be done.</span><dd><ul class="first last simple">
<li><em>meshpoints</em> &gt; 0: The mesh is homogeneous with that many mesh points.</li>
<li><em>meshpoints</em> = 0: The mesh is inhomogeneous with master nodes at the interfaces between layers and denser mesh around them. This density and distribution of the points are controlled by the variables <em>coarse</em>, <em>fine</em> and <em>ultrafine</em>.</li>
<li><em>meshpoints</em> &lt; 0: The exact value does not matter. The mesh is inhomogeneous with master nodes at the interfaces between layers and denser mesh around them. Initially, their density and distribution is controlled by the variables <em>coarse</em>, <em>fine</em> and <em>ultrafine</em> but then this is dynamically modified to increase or reduce their density in a &#8216;smooth&#8217; way, wherever the mesh points are needed more. This dynamic remeshing is performed at different stages of the above solvers. Master nodes are not modified.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first"><strong>growth_rate = 0.7</strong> : Defines how &#8216;fast&#8217; mesh points are increased by the dynamic meshing routine. It should between 0 and 1. Small values produce denser meshes and larger values produce coarser ones.</p>
</li>
<li><p class="first"><strong>coarse = 20e-9</strong></p>
</li>
<li><p class="first"><strong>fine = 1e-9</strong></p>
</li>
<li><dl class="first docutils">
<dt><strong>ultrafine = 0.2e-9</strong></dt>
<dd><p class="first last">Values are in nanometers. Define the structure of the inhomogeneous mesh and the initial dynamic mesh. After defining the master nodes (two nodes separated 0.1 nm per interface), the space between them is divided in equal size elemens smaller or equal than <em>coarse</em>. Then, the coarse elements adjacent to the master nodes are divided in equal size elemens smaller or equal than <em>fine</em>. Finally, the fine elements adjacent to the master nodes are divided in equal size elemens smaller or equal than <em>ultrafine</em>. This structure is static if <em>meshpoints</em> = 0 and evolves if <em>meshpoints</em> &lt; 0 to a smoother configuration.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<img alt="../_images/mesh.png" class="align-center" src="../_images/mesh.png" />
<dl class="function">
<dt id="SetRecombinationParameters">
<code class="descname">SetRecombinationParameters</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#SetRecombinationParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate (1) and deactivate (0) a given recombination mechanism. The &#8216;virtual experiment&#8217; functions above use this function to activate/deactive the generation, depending of whether there is ligth or not. The keywords and default values are:</p>
<ul class="simple">
<li><strong>srh = 1</strong> : Schockley-Read-Hall recombination</li>
<li><strong>rad = 1</strong> : Radiative recombination</li>
<li><strong>aug = 0</strong> : Auger recombination</li>
<li><strong>sur = 1</strong>   : Surface recombination (at the front and back contacts)</li>
<li><strong>gen = 0</strong>   : Generation</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="SetConvergenceParameters">
<code class="descname">SetConvergenceParameters</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#SetConvergenceParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Control the convergence of the solver by changing the maximum number of iterations and the tolerances. The keywords and default values are:</p>
<ul class="simple">
<li><strong>clamp = 20</strong> : In <em>kT</em> units. Limits the maximum change in the electrostatic potential and quasi-Fermi energies at each iteration of the solver. Smaller values migth improve convergence in detriment of the speed.</li>
<li><strong>nitermax = 100</strong> : Maximum number of iterations of the solver.</li>
<li><strong>ATol = 1.5e-08</strong> : Absolute tolerance of the solver. If the residual is smaller than this, the solver will finish. This is the square root of the machine epsilon of <em>numpy.float64</em>. Lower values than this often lead to numerical errors and lack of convergence, in adition to much lower speed.</li>
<li><strong>RTol = 1e-4</strong> : Relative tolerance of the solver. If the difference of the residual between sucessive calculations is smaller than this value, the solver will finish.</li>
</ul>
</dd></dl>

</div>
<div class="section" id="output-dictionary">
<span id="id3"></span><h2>Output dictionary<a class="headerlink" href="#output-dictionary" title="Permalink to this headline">¶</a></h2>
<p>All virtual experiments described above produce a dictionary as output. A variable can be accessed as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="o">&lt;</span><span class="n">primary_key</span><span class="o">&gt;</span><span class="p">][</span><span class="o">&lt;</span><span class="n">secondary_key</span><span class="p">]</span>
</pre></div>
</div>
<p>The total list of primary (columns) and secondary (rows) keys are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Properties</th>
<th class="head">Bandstructure</th>
<th class="head">IV</th>
<th class="head">QE</th>
<th class="head">Optics</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>x</td>
<td>x</td>
<td>V</td>
<td>wavelengths</td>
<td>wavelengths</td>
</tr>
<tr class="row-odd"><td>Xi</td>
<td>n</td>
<td>J</td>
<td>IQE</td>
<td>R</td>
</tr>
<tr class="row-even"><td>Eg</td>
<td>p</td>
<td>Jrad</td>
<td>EQE</td>
<td>T</td>
</tr>
<tr class="row-odd"><td>Nd</td>
<td>ni</td>
<td>Jsrh</td>
<td>IQEsrh</td>
<td>-</td>
</tr>
<tr class="row-even"><td>Na</td>
<td>Rho</td>
<td>Jaug</td>
<td>IQErad</td>
<td>-</td>
</tr>
<tr class="row-odd"><td>Nc</td>
<td>Efe</td>
<td>Jsur</td>
<td>IQEaug</td>
<td>-</td>
</tr>
<tr class="row-even"><td>Nv</td>
<td>Efh</td>
<td>Jsc <a class="reference internal" href="#a" id="id4">[a]</a></td>
<td>IQEsurf</td>
<td>-</td>
</tr>
<tr class="row-odd"><td>-</td>
<td>potential</td>
<td>Voc <a class="reference internal" href="#a" id="id5">[a]</a></td>
<td>IQEsurb</td>
<td>-</td>
</tr>
<tr class="row-even"><td>-</td>
<td>Ec</td>
<td>Jmpp <a class="reference internal" href="#a" id="id6">[a]</a></td>
<td>-</td>
<td>-</td>
</tr>
<tr class="row-odd"><td>-</td>
<td>Ev</td>
<td>Vmpp <a class="reference internal" href="#a" id="id7">[a]</a></td>
<td>-</td>
<td>-</td>
</tr>
<tr class="row-even"><td>-</td>
<td>GR</td>
<td>FF <a class="reference internal" href="#a" id="id8">[a]</a></td>
<td>-</td>
<td>-</td>
</tr>
<tr class="row-odd"><td>-</td>
<td>G</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="row-even"><td>-</td>
<td>Rrad</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="row-odd"><td>-</td>
<td>Rsrh</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="row-even"><td>-</td>
<td>Raug</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[a]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>, <a class="fn-backref" href="#id6">3</a>, <a class="fn-backref" href="#id7">4</a>, <a class="fn-backref" href="#id8">5</a>)</em> Only available in light IV if <em>IV_info=True</em></td></tr>
</tbody>
</table>
</div>
<div class="section" id="module-solcore.poisson_drift_diffusion.DriftDiffusionUtilities">
<span id="all-functions-description"></span><h2>All functions description<a class="headerlink" href="#module-solcore.poisson_drift_diffusion.DriftDiffusionUtilities" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.ProcessStructure">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">ProcessStructure</code><span class="sig-paren">(</span><em>device</em>, <em>wavelengths=None</em>, <em>use_Adachi=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#ProcessStructure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.ProcessStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads a dictionary containing all the device structure, extract the electrical and optical
properties of the materials, and loads all that information into the Fortran variables. Finally, it initiallise the
device (in fortran) calculating an initial mesh and all the properties as a function of the possition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; A dictionary containing the device structure. See PDD.DeviceStructure</li>
<li><strong>wavelengths</strong> &#8211; (Optional) Wavelengths at which to calculate the optical properties.</li>
<li><strong>use_Adachi</strong> &#8211; (Optional) If Adachi model should be use to calculate the dielectric constant of the material.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Dictionary containing the device structure properties as a function of the position.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.Equilibrium">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">Equilibrium</code><span class="sig-paren">(</span><em>device</em>, <em>output_info=2</em>, <em>wavelengths=None</em>, <em>use_Adachi=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#Equilibrium"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.Equilibrium" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the Poisson-DD equations under equilibrium: in the dark with no external current and zero applied voltage. Internally, it calls <em>ProcessStructure</em>. Absorption coeficients are not calculated unless <em>wavelengths</em> is given as input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; A dictionary containing the device structure. See PDD.DeviceStructure</li>
<li><strong>output_info</strong> &#8211; Indicates how much information must be printed by the fortran solver (1=less, 2=more)</li>
<li><strong>wavelengths</strong> &#8211; (Optional) Wavelengths at which to calculate the optical properties.</li>
<li><strong>use_Adachi</strong> &#8211; (Optional) If Adachi model should be use to calculate the dielectric constant of the material.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Dictionary containing the device properties as a function of the position at equilibrium.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.ShortCircuit">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">ShortCircuit</code><span class="sig-paren">(</span><em>device</em>, <em>sol='AM1.5d'</em>, <em>rs=0</em>, <em>output_info=1</em>, <em>use_Reflection=True</em>, <em>use_Adachi=False</em>, <em>optics=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#ShortCircuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.ShortCircuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the devices electronic properties at short circuit. Internally, it calls Equilibrium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; A dictionary containing the device structure. See PDD.DeviceStructure</li>
<li><strong>output_info</strong> &#8211; Indicates how much information must be printed by the fortran solver (0=min, 2=max)</li>
<li><strong>use_Reflection</strong> &#8211; If front surface reflection is to be included in the calculation. If optics is not False, this is ignored.</li>
<li><strong>rs</strong> &#8211; Series resistance. Default=0</li>
<li><strong>sol</strong> &#8211; Either an string indicating the spectrum to use (eg. &#8220;AM1.5d&#8221;) or an Illumination object.</li>
<li><strong>use_Adachi</strong> &#8211; (Optional) If Adachi model should be use to calculate the dielectric constant of the material.</li>
<li><strong>optics</strong> &#8211; <p>Either &#8220;False&#8221; if the generation profile is calculated internally, &#8220;True&#8221; if it has to be calculated using the TMM solver, or a generation profile dictionary. If it is provided exterally, the dictionary must contain:</p>
<ul>
<li>&#8220;position&#8221; : An array with the positions (in m).</li>
<li>&#8220;wavelengths&#8221; : An array with the positions (in m).</li>
<li>&#8220;R&#8221; : An array with the reflection as a function of the wavelength.</li>
<li>&#8220;absorption&#8221; : A 2D array with the fraction of absorbed photons at each wavelength per unit length (in 1/m)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dictionary containing the device properties as a function of the position at short circuit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.IV">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">IV</code><span class="sig-paren">(</span><em>device</em>, <em>vfin</em>, <em>vstep</em>, <em>output_info=1</em>, <em>IV_info=True</em>, <em>rs=0</em>, <em>escape=1</em>, <em>sol=None</em>, <em>use_Adachi=False</em>, <em>optics=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#IV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.IV" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the IV curve of the device between 0 V and a given voltage. Depending if the &#8220;sol&#8221; parameter is set
or not, the IV will be calculated in the dark (calling the Equilibrium function) or under illumination (calling
the ShortCircuit function).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; A dictionary containing the device structure. See PDD.DeviceStructure</li>
<li><strong>vfin</strong> &#8211; Final voltage. If it is negative, vstep must also be negative.</li>
<li><strong>vstep</strong> &#8211; Maximum step size for the IV curve. This is adapted dynamically to ensure that the shape is reproduced correctly.</li>
<li><strong>output_info</strong> &#8211; Indicates how much information must be printed by the fortran solver (0=min, 2=max)</li>
<li><strong>IV_info</strong> &#8211; If information about the Voc, Isc and FF should be provided after the calculation. Default=True</li>
<li><strong>rs</strong> &#8211; Series resistance. Default=0</li>
<li><strong>escape</strong> &#8211; Indicates if the calculation should stop when Voc is reached (0=False, 1=True). Default=1</li>
<li><strong>sol</strong> &#8211; Either an string indicating the spectrum to use (eg. &#8220;AM1.5d&#8221;) or an Illumination object.</li>
<li><strong>use_Adachi</strong> &#8211; (Optional) If Adachi model should be use to calculate the dielectric constant of the material.</li>
<li><strong>optics</strong> &#8211; <p>Either &#8220;False&#8221; if the generation profile is calculated internally, &#8220;True&#8221; if it has to be calculated using the TMM solver, or a generation profile dictionary. If it is provided exterally, the dictionary must contain:</p>
<ul>
<li>&#8220;position&#8221; : An array with the positions (in m).</li>
<li>&#8220;wavelengths&#8221; : An array with the positions (in m).</li>
<li>&#8220;R&#8221; : An array with the reflection as a function of the wavelength.</li>
<li>&#8220;absorption&#8221; : A 2D array with the fraction of absorbed photons at each wavelength per unit length (in 1/m)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dictionary containing the IV curves, the different components and also the output of Equilibrium or ShortCircuit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.QE">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">QE</code><span class="sig-paren">(</span><em>device</em>, <em>sol='AM1.5d'</em>, <em>rs=0</em>, <em>output_info=1</em>, <em>use_Reflection=True</em>, <em>use_Adachi=False</em>, <em>optics=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#QE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.QE" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the quantum efficiency of the device at short circuit. Internally it calls ShortCircuit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; A dictionary containing the device structure. See PDD.DeviceStructure</li>
<li><strong>output_info</strong> &#8211; Indicates how much information must be printed by the fortran solver (0=min, 2=max)</li>
<li><strong>use_Reflection</strong> &#8211; If front surface reflection is to be included in the calculation. If optics is not False, this is ignored.</li>
<li><strong>rs</strong> &#8211; Series resistance. Default=0</li>
<li><strong>sol</strong> &#8211; Either an string indicating the spectrum to use (eg. &#8220;AM1.5d&#8221;) or an Illumination object.</li>
<li><strong>use_Adachi</strong> &#8211; (Optional) If Adachi model should be use to calculate the dielectric constant of the material.</li>
<li><strong>optics</strong> &#8211; <p>Either &#8220;False&#8221; if the generation profile is calculated internally, &#8220;True&#8221; if it has to be calculated using the TMM solver, or a generation profile dictionary. If it is provided exterally, the dictionary must contain:</p>
<ul>
<li>&#8220;position&#8221; : An array with the positions (in m).</li>
<li>&#8220;wavelengths&#8221; : An array with the positions (in m).</li>
<li>&#8220;R&#8221; : An array with the reflection as a function of the wavelength.</li>
<li>&#8220;absorption&#8221; : A 2D array with the fraction of absorbed photons at each wavelength per unit length (in 1/m)</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The internal and external quantum efficiencies, in adition to the output of ShortCircuit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.DumpInputProperties">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">DumpInputProperties</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#DumpInputProperties"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.DumpInputProperties" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.DumpBandStructure">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">DumpBandStructure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#DumpBandStructure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.DumpBandStructure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.DumpIV">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">DumpIV</code><span class="sig-paren">(</span><em>IV_info=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#DumpIV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.DumpIV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.DumpQE">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">DumpQE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#DumpQE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.DumpQE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.SetMeshParameters">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">SetMeshParameters</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#SetMeshParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.SetMeshParameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.SetRecombinationParameters">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">SetRecombinationParameters</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#SetRecombinationParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.SetRecombinationParameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="solcore.poisson_drift_diffusion.DriftDiffusionUtilities.SetConvergenceParameters">
<code class="descclassname">solcore.poisson_drift_diffusion.DriftDiffusionUtilities.</code><code class="descname">SetConvergenceParameters</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/solcore/poisson_drift_diffusion/DriftDiffusionUtilities.html#SetConvergenceParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#solcore.poisson_drift_diffusion.DriftDiffusionUtilities.SetConvergenceParameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="ref1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><ol class="first last upperalpha simple" start="19">
<li>Adachi “Optical dispersion relations for GaP, GaAs, GaSb, InP, InAs, InSb, AlxGa1−xAs, and In1−xGaxAsyP1−y,” J. Appl. Phys.,66, 6030 (1989).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ref4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Reference AM1.5 Spectra. NREL. <a class="reference external" href="http://rredc.nrel.gov/solar/spectra/am1.5/">http://rredc.nrel.gov/solar/spectra/am1.5/</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Drift Diffusion Utilities</a><ul>
<li><a class="reference internal" href="#virtual-experiments">Virtual experiments</a></li>
<li><a class="reference internal" href="#get-data-from-fortran">Get data from Fortran</a></li>
<li><a class="reference internal" href="#setting-different-aspects-of-the-solver">Setting different aspects of the solver</a></li>
<li><a class="reference internal" href="#output-dictionary">Output dictionary</a></li>
<li><a class="reference internal" href="#module-solcore.poisson_drift_diffusion.DriftDiffusionUtilities">All functions description</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="DeviceStructure.html"
                        title="previous chapter">Device Structure</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QWunit.html"
                        title="next chapter">QW unit creator</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/PDD/DriftDiffusionUtilities.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="QWunit.html" title="QW unit creator"
             >next</a> |</li>
        <li class="right" >
          <a href="DeviceStructure.html" title="Device Structure"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Solcore 4.1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="DDsolver.html" >Poisson - Drift-Diffusion solver (PDD)</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Quantum Photovoltaics Group, Imperial College London.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>