
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>solcore.absorption_calculator.transfer_matrix &#8212; Solcore 5.3.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '5.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Solcore 5.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/header2.png" alt="Logo"/>
            </a></p>
<h3><a href="../../../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Installation/installation.html">Installation and configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Structures/structure.html">Structures and support classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Systems/systems.html">Materials and units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../QM/Schrodinger.html">Quantum Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spectral/spectral.html">Light Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Optics/optics.html">Optical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Solvers/solving_solar_cells.html">Solar cell solvers</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for solcore.absorption_calculator.transfer_matrix</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This module serves as interface between solcore structures (junctions, layers, materials...) and the</span>
<span class="sd">transfer matrix package developed by Steven Byrnes and included in the PyPi repository.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">solcore</span>
<span class="kn">from</span> <span class="nn">solcore.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">solcore.structure</span> <span class="k">import</span> <span class="n">ToStructure</span>
<span class="kn">from</span> <span class="nn">solcore.absorption_calculator</span> <span class="k">import</span> <span class="n">tmm_core_vec</span> <span class="k">as</span> <span class="n">tmm</span>

<span class="n">degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>


<div class="viewcode-block" id="OptiStack"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.OptiStack">[docs]</a><span class="k">class</span> <span class="nc">OptiStack</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class that contains an optical structure: a sequence of layers with a thickness and a complex refractive index.</span>

<span class="sd">    It serves as an intermediate step between solcore layers and materials and the stack of thicknesses and</span>
<span class="sd">    and n and k.txt values necessary to run calculations involving TMM. When creating an OptiStack object, the thicknesses</span>
<span class="sd">    of all the layers forming the Solcore structure and the optical data of the materials of the layers are extracted</span>
<span class="sd">    and arranged in such a way they can be easily and fastly read by the TMM functions.</span>

<span class="sd">    In addition to a solcore structure with Layers, it can also take a list where each element represent a layer</span>
<span class="sd">    written as a list and contains the layer thickness and the dielectrical model, the raw n and k data as a function</span>
<span class="sd">    of wavelengths, or a whole Device structure as the type used in the PDD model.</span>

<span class="sd">    In summary, this class acepts:</span>

<span class="sd">        - A solcore structure with layers</span>
<span class="sd">        - A list where each element is [thickness, DielectricModel]</span>
<span class="sd">        - A list where each element is [thickness, wavelength, n, k]</span>
<span class="sd">        - A list mixing the above:</span>
<span class="sd">            [ [thickness, DielectricModel],</span>
<span class="sd">              [thickness, wavelength, n, k],</span>
<span class="sd">              solcore.Layer,</span>
<span class="sd">              solcore.Layer ]</span>

<span class="sd">    This allows for maximum flexibility when creating the optical model, allowing to construct the stack with</span>
<span class="sd">    experimental data, modelled data and known material properties from the database.</span>

<span class="sd">    Yet anther way of defining the layers mixes experimental data with a DielectricModel within the same layer but in</span>
<span class="sd">    spectrally distinct regions. The syntaxis for the layer is:</span>

<span class="sd">    layer = [thickness, wavelength, n, k, DielectricModel, mixing]</span>

<span class="sd">    where mixing is a list containing three elements: [the mixing point (nm), the mixing width (nm),  zero or one]</span>
<span class="sd">    depending if the mixing function should be increasing with the wavelength or decreasing. If increasing (zero), the</span>
<span class="sd">    Dielectric model will be used at long wavelengths and the experimental data at short wavelengths. If decreasing</span>
<span class="sd">    (one) the oposite is done. The mixing point and mixing width control how smooth is the transition between one and</span>
<span class="sd">    the other type of data.</span>

<span class="sd">    Extra layers such as he semi-infinite, air-like first and last medium, and a back highly absorbing layer are</span>
<span class="sd">    included at runtime to fulfill the requirements of the TMM solver or to solve some of its limitations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="p">(),</span> <span class="n">no_back_reflexion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Class constructor. It takes a Solcore structure and extract the thickness and optical data from the</span>
<span class="sd">        Layers and the materials. Option is given to indicate if the reflexion from the back of the structure must be</span>
<span class="sd">        supressed, usefull for ellipsometry calculations. This is done by creating an artificial highly absorbing but</span>
<span class="sd">        not reflecting layer just at the back.</span>

<span class="sd">        Alternativelly, it can take simply a list of [thickness, DielectricModel] or [thickness, wavelength, n, k.txt] for</span>
<span class="sd">        each layer accounting for the refractive index of the layers. The three options can be mixed for maximum</span>
<span class="sd">        flexibility.</span>

<span class="sd">        :param structure: A list with one or more layers.</span>
<span class="sd">        :param no_back_reflexion: If reflexion from the back must be supressed. Default=False.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_layers</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">no_back_reflexion</span> <span class="o">=</span> <span class="n">no_back_reflexion</span>

<div class="viewcode-block" id="OptiStack.get_indices"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.OptiStack.get_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the complex refractive index of the stack.</span>

<span class="sd">        :param wl: Wavelength of the light in nm.</span>
<span class="sd">        :return: A list with the complex refractive index of each layer, including the semi-infinite front and back</span>
<span class="sd">        layers and, opionally, the back absorbing layer used to suppress back surface relfexion.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">wl_m</span> <span class="o">=</span> <span class="n">solcore</span><span class="o">.</span><span class="n">si</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">):</span>
            <span class="n">n0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n0</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">wl_m</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">wl_m</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">j</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_back_reflexion</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">+</span> <span class="n">out</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">wl_m</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_absorbing</span><span class="p">(</span><span class="n">wl_m</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">j</span><span class="p">,</span> <span class="n">n0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">+</span> <span class="n">out</span> <span class="o">+</span> <span class="p">[</span><span class="n">n0</span><span class="p">]</span></div>

<div class="viewcode-block" id="OptiStack.get_widths"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.OptiStack.get_widths">[docs]</a>    <span class="k">def</span> <span class="nf">get_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the widths of the layers of the stack.</span>

<span class="sd">        :return: A list with the widths each layer, including the semi-infinite front and back layers and, opionally,</span>
<span class="sd">        the back absorbing layer used to suppress back surface relfexion, defined as 1 mm thick.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_back_reflexion</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_k_absorbing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; k.txt value of the back highly absorbing layer. It is the maximum between the bottom layer of the stack or a</span>
<span class="sd">        finite, small value that will absorb all light within the absorbing layer thickness.</span>

<span class="sd">        :param wl: Wavelength of the light in nm.</span>
<span class="sd">        :return: The k.txt value at each wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">wl</span> <span class="o">/</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">wl</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_k_dummy</span><span class="p">(</span><span class="n">wl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Dummy k.txt value to be used with the dielectric model, which produces the refractive index as a complex</span>
<span class="sd">        number.</span>

<span class="sd">        :param wl: Wavelength of the light in nm.</span>
<span class="sd">        :return: The k.txt value at each wavelength... set to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.</span>

<div class="viewcode-block" id="OptiStack.add_layers"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.OptiStack.add_layers">[docs]</a>    <span class="k">def</span> <span class="nf">add_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generic function to add layers to the OptiStack. Internally, it calls add_solcore_layer,</span>
<span class="sd">        add_modelled_layer or add_raw_nk_layer.</span>

<span class="sd">        :param layers: A list with the layers to add (even if it is just one layer) It can be one or more and it can</span>
<span class="sd">        mixed, Solcore-based and modelled layers.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If the input is a whole device structure, we get just the layers information</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">layers</span> <span class="o">=</span> <span class="n">ToStructure</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;Layer&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">layer</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_solcore_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s1">&#39;DielectricConstantModel&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_modelled_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_raw_nk_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error when adding a new layer to the OptiStack. </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">))</span></div>

<div class="viewcode-block" id="OptiStack.remove_layer"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.OptiStack.remove_layer">[docs]</a>    <span class="k">def</span> <span class="nf">remove_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes layer with index idx from the OptiStack</span>

<span class="sd">        :param idx: Index of the layer to remove</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error when removing layers. idx must be: 0 &lt;= idx &lt;= </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">-=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="OptiStack.swap_layers"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.OptiStack.swap_layers">[docs]</a>    <span class="k">def</span> <span class="nf">swap_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Swaps two layers in the OptiStack.</span>

<span class="sd">        :param idx1: The index of one of the layers.</span>
<span class="sd">        :param idx2: The index of the other.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="ow">or</span> <span class="n">idx2</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error when removing layers. idx must be: 0 &lt;= idx1, idx2 &lt;= </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">idx2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">idx2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="p">[</span><span class="n">idx2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="p">[</span><span class="n">idx2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_add_solcore_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Adds a Solcore layer to the end (bottom) of the stack, extracting its thickness and n and k.txt data.</span>

<span class="sd">        :param layer: The Solcore layer</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solcore</span><span class="o">.</span><span class="n">asUnit</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_modelled_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Adds a layer to the end (bottom) of the stack. The layer must be defined as a list containing the layer</span>
<span class="sd">        thickness in nm and a dielectric model.</span>

<span class="sd">        :param layer: The new layer to add as [thickness, DielectricModel]</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">n_and_k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k_dummy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_raw_nk_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Adds a layer to the end (bottom) of the stack. The layer must be defined as a list containing the layer</span>
<span class="sd">        thickness in nm, the wavelength, the n and the k data as array-like objects.</span>

<span class="sd">        :param layer: The new layer to add as [thickness, wavelength, n, k]</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We make sure that the wavelengths are increasing, revering the arrays otherwise.</span>
        <span class="k">if</span> <span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">layer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">layer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="mi">3</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">solcore</span><span class="o">.</span><span class="n">si</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;nm&#39;</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">solcore</span><span class="o">.</span><span class="n">si</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;nm&#39;</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># = 0 for increasing, =1 for decreasing</span>

            <span class="k">def</span> <span class="nf">mix</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>

                <span class="n">out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">w</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">out</span>

                <span class="k">return</span> <span class="n">out</span>

            <span class="n">n_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">n_and_k</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">mix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mix</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">*</span> <span class="n">interp1d</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">solcore</span><span class="o">.</span><span class="n">si</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;nm&#39;</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">layer</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">layer</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">k_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">solcore</span><span class="o">.</span><span class="n">si</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;nm&#39;</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">layer</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">layer</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])(</span><span class="n">x</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k_data</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">solcore</span><span class="o">.</span><span class="n">si</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;nm&#39;</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">layer</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">layer</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">solcore</span><span class="o">.</span><span class="n">si</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;nm&#39;</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">layer</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">layer</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span></div>


<div class="viewcode-block" id="calculate_rat"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.calculate_rat">[docs]</a><span class="k">def</span> <span class="nf">calculate_rat</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">coherent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coherency_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">no_back_reflexion</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculates the reflected, absorbed and transmitted intensity of the structure for the wavelengths and angles</span>
<span class="sd">    defined.</span>

<span class="sd">    :param structure: A solcore Structure object with layers and materials or a OptiStack object.</span>
<span class="sd">    :param wavelength: Wavelengths (in nm) in which calculate the data. An array.</span>
<span class="sd">    :param angle: Angle (in degrees) of the incident light. Default: 0 (normal incidence).</span>
<span class="sd">    :param pol: Polarisation of the light: &#39;s&#39;, &#39;p&#39; or &#39;u&#39;. Default: &#39;u&#39; (unpolarised).</span>
<span class="sd">    :param coherent: If the light is coeherent or not. If not, a coherency list must be added.</span>
<span class="sd">    :param coherency_list: A list indicating in which layers light should be treated as coeherent (&#39;c&#39;) and in which</span>
<span class="sd">    incoherent (&#39;i&#39;). It needs as many elements as layers in the structure.</span>
<span class="sd">    :param no_back_reflexion: If reflexion from the back must be supressed. Default=True.</span>
<span class="sd">    :return: A dictionary with the R, A and T at the specified wavelengths and angle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_wl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;OptiStack&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">structure</span><span class="p">)):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">no_back_reflexion</span> <span class="o">=</span> <span class="n">no_back_reflexion</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">OptiStack</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">no_back_reflexion</span><span class="o">=</span><span class="n">no_back_reflexion</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">coherent</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coherency_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coherency_list</span><span class="p">)</span> <span class="o">==</span> <span class="n">stack</span><span class="o">.</span><span class="n">num_layers</span><span class="p">,</span> \
                <span class="s1">&#39;Error: The coherency list must have as many elements (now </span><span class="si">{}</span><span class="s1">) as the &#39;</span> \
                <span class="s1">&#39;number of layers (now </span><span class="si">{}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coherency_list</span><span class="p">),</span> <span class="n">stack</span><span class="o">.</span><span class="n">num_layers</span><span class="p">)</span>
            <span class="n">coherency_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">coherency_list</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Error: For incoherent or partly incoherent calculations you must supply the &#39;</span>
                            <span class="s1">&#39;coherency_list parameter with as many elements as the number of layers in the &#39;</span>
                            <span class="s1">&#39;structure&#39;</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_wl</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_wl</span><span class="p">),</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_wl</span><span class="p">),</span> <span class="s1">&#39;all_p&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;all_s&#39;</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="k">if</span> <span class="n">pol</span> <span class="ow">in</span> <span class="s1">&#39;sp&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coherent</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">coh_tmm</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">wavelength</span><span class="p">),</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_widths</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">degree</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wavelength</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">inc_tmm</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">wl</span><span class="p">),</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_widths</span><span class="p">(),</span> <span class="n">coherency_list</span><span class="p">,</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">degree</span><span class="p">,</span> <span class="n">wl</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span>
                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coherent</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">unpolarized_RT</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">wavelength</span><span class="p">),</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_widths</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">degree</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wavelength</span><span class="p">):</span>
                <span class="n">out_p</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">inc_tmm</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">wl</span><span class="p">),</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_widths</span><span class="p">(),</span> <span class="n">coherency_list</span><span class="p">,</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">degree</span><span class="p">,</span> <span class="n">wl</span><span class="p">)</span>
                <span class="n">out_s</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">inc_tmm</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">wl</span><span class="p">),</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_widths</span><span class="p">(),</span> <span class="n">coherency_list</span><span class="p">,</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">degree</span><span class="p">,</span> <span class="n">wl</span><span class="p">)</span>

                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">out_p</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">out_s</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">])</span>
                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">out_p</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">out_s</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">])</span>
                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;all_p&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_p</span><span class="p">[</span><span class="s1">&#39;power_entering_list&#39;</span><span class="p">])</span>
                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;all_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_s</span><span class="p">[</span><span class="s1">&#39;power_entering_list&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="calculate_ellipsometry"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.calculate_ellipsometry">[docs]</a><span class="k">def</span> <span class="nf">calculate_ellipsometry</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">no_back_reflexion</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculates the ellipsometric parameters psi and delta. It can only deal with coherent light and the whole stack</span>
<span class="sd">    (including back surface) is considered, so caution must be taken when comparing the simulated results with</span>
<span class="sd">    experiments where the back surface is rough or layers are thick and coherent light propagation makes no sense.</span>

<span class="sd">    The optional argument no_back_reflexion can be included to add an extra layer on the back absorbing all light that</span>
<span class="sd">    reaches that position without any reflexion, to remove the reflexion from the back surface.</span>

<span class="sd">    :param structure: A solcore structure with layers and materials.</span>
<span class="sd">    :param wavelength: Wavelengths (in nm) in which calculate the data. An array.</span>
<span class="sd">    :param angle: A tupple or list with the angles (in degrees) in which to calculate the data.</span>
<span class="sd">    :param no_back_reflexion: If reflexion from the back must be supressed. Default=True.</span>
<span class="sd">    :return: A dictionary with psi and delta at the specified wavelengths and angles (2D arrays).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_wl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span>
    <span class="n">num_ang</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;OptiStack&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">structure</span><span class="p">)):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">no_back_reflexion</span> <span class="o">=</span> <span class="n">no_back_reflexion</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">OptiStack</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">no_back_reflexion</span><span class="o">=</span><span class="n">no_back_reflexion</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;psi&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_wl</span><span class="p">,</span> <span class="n">num_ang</span><span class="p">)),</span> <span class="s1">&#39;Delta&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_wl</span><span class="p">,</span> <span class="n">num_ang</span><span class="p">))}</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ang</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">ellips</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">wavelength</span><span class="p">),</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_widths</span><span class="p">(),</span> <span class="n">ang</span> <span class="o">*</span> <span class="n">degree</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;psi&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;psi&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">degree</span>

        <span class="c1"># We revere the sign of Delta in order to use Woollam sign convention</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">degree</span>

        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">180</span> <span class="o">-</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">],</span>
                                         <span class="n">output</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">output</span></div>


<span class="c1"># def calculate_absorption_profile(structure, wavelength, z_limit=None, steps_size=2, dist=None,</span>
<span class="c1">#                                  no_back_reflexion=True):</span>
<span class="c1">#     &quot;&quot;&quot; It calculates the absorbed energy density within the material. From the documentation:</span>
<span class="c1">#</span>
<span class="c1">#     &#39;In principle this has units of [power]/[volume], but we can express it as a multiple of incoming light power</span>
<span class="c1">#     density on the material, which has units [power]/[area], so that absorbed energy density has units of 1/[length].&#39;</span>
<span class="c1">#</span>
<span class="c1">#     Integrating this absorption profile in the whole stack gives the same result that the absorption obtained with</span>
<span class="c1">#     calculate_rat as long as the spacial mesh (controlled by steps_thinest_layer) is fine enough. If the structure is</span>
<span class="c1">#     very thick and the mesh not thin enough, the calculation might diverege at short wavelengths.</span>
<span class="c1">#</span>
<span class="c1">#     For now, it only works for normal incident, coherent light.</span>
<span class="c1">#</span>
<span class="c1">#     :param structure: A solcore structure with layers and materials.</span>
<span class="c1">#     :param wavelength: Wavelengths in which calculate the data (in nm). An array-like object.</span>
<span class="c1">#     :param z_limit: Maximum value in the z direction</span>
<span class="c1">#     :return: A dictionary containing the positions (in nm) and a 2D array with the absorption in the structure as a</span>
<span class="c1">#     function of the position and the wavelength.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     num_wl = len(wavelength)</span>
<span class="c1">#</span>
<span class="c1">#     if &#39;OptiStack&#39; in str(type(structure)):</span>
<span class="c1">#         stack = structure</span>
<span class="c1">#         stack.no_back_reflexion = no_back_reflexion</span>
<span class="c1">#     else:</span>
<span class="c1">#         stack = OptiStack(structure, no_back_reflexion=no_back_reflexion)</span>
<span class="c1">#</span>
<span class="c1">#     if dist is None:</span>
<span class="c1">#         if z_limit is None:</span>
<span class="c1">#             z_limit = np.sum(np.array(stack.widths))</span>
<span class="c1">#         dist = np.arange(0, z_limit, steps_size)</span>
<span class="c1">#</span>
<span class="c1">#     output = {&#39;position&#39;: dist, &#39;absorption&#39;: np.zeros((num_wl, len(dist)))}</span>
<span class="c1">#</span>
<span class="c1">#     for i, wl in enumerate(wavelength):</span>
<span class="c1">#         out = tmm.coh_tmm(&#39;p&#39;, stack.get_indices(wl), stack.get_widths(), 0, wl)</span>
<span class="c1">#         for j, d in enumerate(dist):</span>
<span class="c1">#             layer, d_in_layer = tmm.find_in_structure_with_inf(stack.get_widths(), d)</span>
<span class="c1">#             data = tmm.position_resolved(layer, d_in_layer, out)</span>
<span class="c1">#             output[&#39;absorption&#39;][i, j] = data[&#39;absor&#39;]</span>
<span class="c1">#</span>
<span class="c1">#     return output</span>


<div class="viewcode-block" id="calculate_absorption_profile"><a class="viewcode-back" href="../../../Optics/tmm.html#solcore.absorption_calculator.transfer_matrix.calculate_absorption_profile">[docs]</a><span class="k">def</span> <span class="nf">calculate_absorption_profile</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">z_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">steps_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">no_back_reflexion</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; It calculates the absorbed energy density within the material. From the documentation:</span>

<span class="sd">    &#39;In principle this has units of [power]/[volume], but we can express it as a multiple of incoming light power</span>
<span class="sd">    density on the material, which has units [power]/[area], so that absorbed energy density has units of 1/[length].&#39;</span>

<span class="sd">    Integrating this absorption profile in the whole stack gives the same result that the absorption obtained with</span>
<span class="sd">    calculate_rat as long as the spacial mesh (controlled by steps_thinest_layer) is fine enough. If the structure is</span>
<span class="sd">    very thick and the mesh not thin enough, the calculation might diverege at short wavelengths.</span>

<span class="sd">    For now, it only works for normal incident, coherent light.</span>

<span class="sd">    :param structure: A solcore structure with layers and materials.</span>
<span class="sd">    :param wavelength: Wavelengths in which calculate the data (in nm). An array</span>
<span class="sd">    :param z_limit: Maximum value in the z direction</span>
<span class="sd">    :return: A dictionary containing the positions (in nm) and a 2D array with the absorption in the structure as a</span>
<span class="sd">    function of the position and the wavelength.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_wl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;OptiStack&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">structure</span><span class="p">)):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">no_back_reflexion</span> <span class="o">=</span> <span class="n">no_back_reflexion</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">OptiStack</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">no_back_reflexion</span><span class="o">=</span><span class="n">no_back_reflexion</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">z_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">widths</span><span class="p">))</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z_limit</span><span class="p">,</span> <span class="n">steps_size</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="n">dist</span><span class="p">,</span> <span class="s1">&#39;absorption&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_wl</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)))}</span>

    <span class="c1"># print(stack.get_indices(wavelength).shape)</span>
    <span class="n">out1</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">coh_tmm</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">wavelength</span><span class="p">),</span> <span class="n">stack</span><span class="o">.</span><span class="n">get_widths</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span>
    <span class="n">layer</span><span class="p">,</span> <span class="n">d_in_layer</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">find_in_structure_with_inf</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">get_widths</span><span class="p">(),</span> <span class="n">dist</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">tmm</span><span class="o">.</span><span class="n">position_resolved</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">d_in_layer</span><span class="p">,</span> <span class="n">out1</span><span class="p">)</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;absorption&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;absor&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">output</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">from</span> <span class="nn">solcore</span> <span class="k">import</span> <span class="n">material</span><span class="p">,</span> <span class="n">si</span>
    <span class="kn">from</span> <span class="nn">solcore.structure</span> <span class="k">import</span> <span class="n">Layer</span><span class="p">,</span> <span class="n">Structure</span>

    <span class="n">GaAs</span> <span class="o">=</span> <span class="n">material</span><span class="p">(</span><span class="s1">&#39;GaAs&#39;</span><span class="p">)(</span><span class="n">T</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="n">InGaAs</span> <span class="o">=</span> <span class="n">material</span><span class="p">(</span><span class="s1">&#39;InGaAs&#39;</span><span class="p">)(</span><span class="n">T</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">In</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="n">my_structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">([</span>
        <span class="n">Layer</span><span class="p">(</span><span class="n">si</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">),</span> <span class="n">material</span><span class="o">=</span><span class="n">InGaAs</span><span class="p">),</span>
        <span class="n">Layer</span><span class="p">(</span><span class="n">si</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;um&#39;</span><span class="p">),</span> <span class="n">material</span><span class="o">=</span><span class="n">GaAs</span><span class="p">),</span>

    <span class="p">])</span>

    <span class="n">wavelength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">450</span><span class="p">,</span> <span class="mi">1100</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">calculate_rat</span><span class="p">(</span><span class="n">my_structure</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">coherent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">no_back_reflexion</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># #</span>
    <span class="c1"># plt.plot(wavelength, out[&#39;R&#39;], &#39;b&#39;, label=&#39;Reflexion&#39;)</span>
    <span class="c1"># plt.plot(wavelength, out[&#39;A&#39;], &#39;r&#39;, label=&#39;Absorption&#39;)</span>
    <span class="c1"># plt.plot(wavelength, out[&#39;T&#39;], &#39;g&#39;, label=&#39;Transmission&#39;)</span>
    <span class="c1"># plt.legend()</span>
    <span class="c1"># plt.show()</span>

    <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">70</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">calculate_ellipsometry</span><span class="p">(</span><span class="n">my_structure</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angles</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;psi&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;psi&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Delta&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;psi&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;Delta&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># plt.legend()</span>

    <span class="c1"># out = calculate_absorption_profile_2(my_structure, wavelength, z_limit=3000)</span>
    <span class="c1"># # print(tuple(out[&#39;absorption&#39;][0]))</span>
    <span class="c1"># # plt.plot(out[&#39;position&#39;], out[&#39;absorption&#39;][0])</span>
    <span class="c1"># A = np.zeros_like(wavelength)</span>
    <span class="c1"># #</span>
    <span class="c1"># for i, absorption in enumerate(out[&#39;absorption&#39;][:]):</span>
    <span class="c1">#     A[i] = np.trapz(absorption, out[&#39;position&#39;])</span>
    <span class="c1"># #</span>
    <span class="c1"># plt.plot(wavelength, A, &#39;k&#39;, label=&#39;Integrated Abs&#39;)</span>

    <span class="c1">#</span>
    <span class="c1"># plt.contourf(out[&#39;position&#39;], wavelength, out[&#39;absorption&#39;], 200)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Solcore 5.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Quantum Photovoltaics Group, Imperial College London.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>